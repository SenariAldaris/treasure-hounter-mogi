!
  пользовательского интерфейса jQuery 1.8.9
 
  Авторское право 2011, AUTHORS.txt (httpjqueryui.comabout)
  Двойной лицензией mit или GPL версии 2 лицензии.
  httpjquery.orglicense
 
  httpdocs.jquery.comUI
 
(функция( $, не определено ) {
 
 предотвращения повторной загрузки
 это единственная проблема, потому что мы прокси существующих функций
 и мы не хотим двойных прокси их
$.пользовательский интерфейс = $.пользовательского интерфейса  {};
если ( $.пользовательского интерфейса.версия ) {
    возврат;
}
 
$.продлить( $.пользовательского интерфейса, {
    версия 1.8.9,
 
    код {
        АЛТ 18,
        Забой 8,
        CAPS_LOCK 20,
        Запятая 188,
        Команда 91,
        COMMAND_LEFT 91,  КОМАНДА
        COMMAND_RIGHT 93,
        Контроль 17,
        Удаление 46,
        Вниз 40,
        Конец 35,
        Ввод 13,
        Побег 27,
        Дома 36,
        Вставки 45,
        Слева 37,
        МЕНЮ 93,  COMMAND_RIGHT
        NUMPAD_ADD 107,
        NUMPAD_DECIMAL 110,
        NUMPAD_DIVIDE 111,
        NUMPAD_ENTER 108,
        NUMPAD_MULTIPLY 106,
        NUMPAD_SUBTRACT 109,
        PAGE_DOWN 34,
        PAGE_UP 33,
        Период 190,
        Прямо 39,
        Смена 16,
        Площадь 32,
        Вкладка 9,
        До 38,
        ОКНА 91  КОМАНДА
    }
});
 
 плагины
$.ФН.расширить({
    _focus $.ФН.фокус,
    фокусировка функция( задержка, ФН ) {
        возвращение typeof на задержки === число 
            это.каждый(функция() {
                вар элем = это;
                функции settimeout(функция() {
                    $( элем ).фокус();
                    если клавиша( FN ) {
                        ФН.вызов( элем );
                    }
                }, задержка );
            }) 
            это._focus.по Apply( это, аргументы );
    },
 
    scrollParent функция() {
        вар scrollParent;
        если (($.браузер.встроенный msie && ((статическийотносительная)).тест(это.в CSS('позиции')))  (абсолютное).тест(это.в CSS('позиции'))) {
            scrollParent = это.родители().фильтр(функция() {
                возвращение ((относительнаяабсолютнаяфиксированная)).тест($.curCSS(это,'позиции',1)) && ((автопрокрутки)).тест($.curCSS(это,'переполнение',1)+$.curCSS(это,'переполнение-г',1)+$.curCSS(это,'переполнение-х',1));
            }).эквалайзер(0);
        } еще {
            scrollParent = это.родители().фильтр(функция() {
                возвращение ((автопрокрутки)).тест($.curCSS(это,'переполнение',1)+$.curCSS(это,'переполнение-г',1)+$.curCSS(это,'переполнение-х',1));
            }).эквалайзер(0);
        }
 
        возвращение (стационарная).тест(это.в CSS('позиции'))  !scrollParent.длина  $(документ)  scrollParent;
    },
 
    значением zindex отобразится функцией( значением zindex отобразится ) {
        если ( значением zindex отобразится !== значение Undefined ) {
            вернуть это.в CSS( значением zindex отобразится, значением zindex отобразится );
        }
 
        если ( это.длина ) {
            вар элем = $( это[ 0 ] ), позиции, ценности;
            пока ( элем.длина && элем[ 0 ] !== документа ) {
                 Игнорировать значения Z-индекса если позиция имеет значение, где Z-индекс игнорируется браузером
                 Это делает поведение этой функции последовательно через браузеры
                 На базе WebKit всегда возвращает авто, если элемент позиционируется
                позиция = элем.в CSS( позиция );
                если ( позиция === абсолютная  позиция === относительный  позиция === фиксированной ) {
                     Т. е. возвращает 0, когда значением zindex отобразится не указан
                     других браузерах возвращать строку
                     мы игнорируем случае вложенных элементов с явным значением 0
                     div стиль=Z-индекса -10;div стиль=Z-индекса 0;делдел
                    значение = parseInt( элем.в CSS( значением zindex отобразится ), 10 );
                    если ( !isNaN( значение ) && значение !== 0 ) {
                        возвращаемое значение;
                    }
                }
                элем = элем.родитель();
            }
        }
 
        возврат 0;
    },
 
    disableSelection функция() {
        вернуть это.привязать( ( $.поддержки.selectstart  selectstart  событиями mousedown ) +
            .пользовательский интерфейс-disableSelection, функция( событие ) {
                событие.метод preventdefault();
            });
    },
 
    enableSelection функция() {
        вернуть это.отменить привязку( .пользовательский интерфейс-disableSelection );
    }
});
 
$.друг( [ ширина, высота ], функция( я, фамилия ) {
    вар стороне = название === Ширина  [ Слева, Справа ]  [ Вверху, Внизу ],
        Тип = имя.столоверчением(),
        ориг = {
            innerWidth $.ФН.innerWidth,
            innerHeight $.ФН.innerHeight,
            outerWidth $.ФН.outerWidth,
            outerHeight $.ФН.outerHeight
        };
 
    функция сокращения( элем, Размер, границы, маржа ) {
        $.каждый( стороны, функция() {
            Размер -= parseFloat( $.curCSS( элем, обивка + это, правда) )  0;
            если ( границы ) {
                Размер -= parseFloat( $.curCSS( элем, граница + этот + Ширина, истина) )  0;
            }
            если ( маржа ) {
                Размер -= parseFloat( $.curCSS( элем, маржа + это, правда) )  0;
            }
        });
        вернуть Размер;
    }
 
    $.сочетание клавиш FN[ внутренний + имя ] = функция( Размер ) {
        если ( размер === неопределенная ) {
            возвращение ориг[ внутренний + имя ].вызов( этот );
        }
 
        вернуть это.каждый(функция() {
            $( этот ).УСБ( типа, уменьшить( это размер ) + пикселей );
        });
    };
 
    $.сочетание клавиш FN[ космического + имя] = функция( размера маржи ) {
        если ( typeof на размер !== число ) {
            возвращение ориг[ космического + имя ].вызов( это, размер );
        }
 
        вернуть это.каждый(функция() {
            $( этот).УСБ( типа, уменьшить( это, размер, правда, маржа ) + пикселей );
        });
    };
});
 
 селекторов
видимая функция( элемент ) {
    возвращение !$( элемент ).родители().andSelf().фильтр(функция() {
        возврат $.curCSS( этот, видимость ) === скрытые 
            $.выраж.фильтры.скрытые( этот );
    }).длина;
}
 
$.продлить( $.выражение[  ], {
    данные функция( elem, так я, матч ) {
        возвращение !!$.данных( элем, матч[ 3 ] );
    },
 
    фокусируемый функция( элемент ) {
        вар имя_узла = элемент.имя_узла.столоверчением(),
            свойство tabindex = $.attr объекта( элемент, свойство tabindex );
        если ( зона === имя_узла ) {
            var карта = элемент.parentNode,
                имя карты = карта.имя,
                имг;
            если ( !элемент.в href  !имя карты  карта.имя_узла.столоверчением() !== карта ) {
                возвратить false;
            }
            компания IMG = $( имг[usemap=# + имя карты + ] )[0];
            возвращение !!компания IMG && видимым( в IMG );
        }
        возвращение ( вводавыборатекстовое полекнопкаобъект.тест( имя_узла )
             !элемент.инвалидов
             а == имя_узла
                 элемент.в href  !isNaN( свойство tabindex )
                 !isNaN( свойство tabindex ))
             стихия и все ее предки должны быть видны
            && видимым( элемент );
    },
 
    tabbable функция( элемент ) {
        вар свойства tabindex = $.attr объекта( элемент, свойство tabindex );
        возвращение ( isNaN( свойство tabindex )  свойство tabindex = 0 ) && $( элемент ).это( фокусируемый );
    }
});
 
 поддержки
$(функция() {
    вар тела = документ.тело,
        див = тело.метода appendchild( div с = документ.ему( див ) );
 
    $.продлить( разд.стиль, {
        свойство minheight 100 пикселей,
        высота авто,
        обивка 0,
        borderWidth 0
    });
 
    $.поддержки.свойство minheight = разд.offsetHeight === 100;
    $.поддержки.selectstart = onselectstart в первенстве МХЛ;
 
     установить дисплей none, чтобы избежать макет баг в IE
     httpdev.jquery.comticket4014
    тела.removechild и( див ).стиль.Дисплей = нет;
});
 
 
 
 
 
 устаревшие
$.продлить( $.пользовательского интерфейса, {
     $.пользовательского интерфейса.плагин устарел. Использовать прокси-шаблон вместо этого.
    плагин {
        добавить функция( модуль, параметр, комплект ) {
            прото вар = $.пользовательского интерфейса[ модуль ].прототип;
            для ( вар я в Set ) {
                прото.плагины[ я ] = прото.плагины[ я ]  [];
                прото.плагины[ я ].метод push( [ параметр, установите для параметра[ я ] ] );
            }
        },
        звоните функция( экземпляр, название, параметр args ) {
            Варе комплект = экземпляре.плагины[ имя ];
            если ( !установить  !инстанции.элемент[ 0 ].parentNode ) {
                возврат;
            }
     
            для ( вар я = 0; я  набор.длина; я++ ) {
                если ( экземпляра.опции[ установить[ я ][ 0 ] ] ) {
                    набор[ я ][ 1 ].применить( экземпляра.элемент, параметр args );
                }
            }
        }
    },
     
     будет прекращена тогда, когда мы переходим к jQuery 1.4 - использование jQuery.содержит()
    содержит функция( а, b ) {
        документ возврата.compareDocumentPosition 
            собой.compareDocumentPosition( б ) & 16 
            есть !== б && собой.содержит( б );
    },
     
     только с использованием изменяемого размера
    hasScroll функция( Эль, а ) {
     
        Если переполнение скрытый элемент может иметь дополнительный контент, но пользователь хочет скрыть это
        если ( $( Эль ).в CSS( переполнение ) === скрыт) {
            возвратить false;
        }
     
        вар прокрутки = ( а && в === ушел )  scrollLeft  scrollTop,
            есть = ложь;
     
        если ( Эль[ свиток ]  0 ) {
            возвратите True;
        }
     
         Todo для определения того, какие дела на самом деле причиной этому случиться
         если элемент не'т иметь свиток установить, посмотреть, если можно
         установка прокрутки
        Эль[ свиток ] = 1;
        имеет = ( Эль[ свиток ]  0 );
        Эль[ свиток ] = 0;
        возвращение имеет;
    },
     
     эти странные функции, исправить API или переместить в отдельные плагины
    isOverAxis функция( х, ссылка, Размер ) {
        Определяет, когда координата x находится над б элемента оси
        возвращение ( х  ссылка ) && ( х  ( ссылка + Размер ) );
    },
    изовер функция( Г, х, сверху, слева, высота, ширина ) {
        Определяет, когда x, y-координаты окончена б элемента
        возврат $.пользовательского интерфейса.isOverAxis( у, верх, высота ) && $.пользовательского интерфейса.isOverAxis( x, влево, Ширина );
    }
});
 
})( библиотека jQuery );